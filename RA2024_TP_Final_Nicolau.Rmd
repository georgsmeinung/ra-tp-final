::: {style="text-align: center;"}
![](logo-austral.png){width="200px"}
:::

---
title: "Regresión Avanzada 2024"
subtitle: "Trabajo Práctico Final"
author: "Jorge Nicolau"
output:
   html_document:
     toc: true
     code_folding: show
     toc_float: false
     df_print: paged
     theme: united
     code_download: true
     toc_depth: 2
editor_options: 
  markdown: 
    wrap: none
---

```{r setup, include=FALSE}
# Limpieza del Workspace
rm(list = ls())

# Determinar el directorio del script actual
# y cambiar el working directory al directorio del script actual
library(rstudioapi)
script_full_path <- rstudioapi::getSourceEditorContext()$path
script_path <- file.path(dirname(script_full_path), "")
setwd(script_path)

knitr::opts_chunk$set(echo = TRUE)
# Deshabilita la impresión de tus resultados en notación científica
options(scipen=999)
```

# Preprocesamiento de Datos

El dataset de exoplanetas detectados por la misión Kepler contiene información sobre 28.217 exoplanetas (entre confirmados y propuetos) y sus características. El objetivo de este trabajo es preprocesar los datos para realizar un análisis exploratorio y utilizar regresión linea y logística para la extracción de paramétros faltantes de los exoplanetas y para predecir la habitabilidad de los mismos.

Se cargarán los datos, se filtrarán las filas de los explonetas confirmados, las columnas relevantes, se eliminarán los valores faltantes y se realizará un análisis exploratorio de los datos.

## Carga de Datos

Se cargan los datos del dataset de exoplanetas de la misión Kepler del archivo `keplerexoplanets.csv`. El mismo se obtuvo de la página del IPAC del Caltech (<https://exoplanetarchive.ipac.caltech.edu/cgi-bin/TblView/nph-tblView?app=ExoTbls&config=PS>) y contiene información sobre los sistemas exoplanetaarios detectados por la misión Kepler (<https://science.nasa.gov/mission/kepler/>).

```{r load_data, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(readr)

# Cargar los datos
kepler_data <- read_csv("keplerexoplanets.csv")
```

**Estructura de los Datos**

```{r show_data_str, echo=FALSE}

library(knitr)

# Capturar la salida de str() como texto
str_output <- capture.output(str(kepler_data, list.len = Inf, give.attr=FALSE))

# Convertir la salida en un data frame para formatearla como tabla
str_df <- data.frame(
  Details = str_output,
  stringsAsFactors = FALSE
)

# Mostrar la salida en formato de tabla con kable
kable(str_df, col.names = c("Tipo de datos y previsualización"), align = "l")

```

Se eliman las columnas con referencias a sitios web no relevantes para el análisis. También se eliminan los datos de referencia de los planetas, estrellas y sistemas no relevantes para el análisis.

Como se busca predecir la habitabilidad de los exoplanetas, se filtran los sistemas con estrellas de tamaño similar al Sol (0.9 a 1.1 radios solares). Hay muchas entradas con valores faltantes en las columnas de tipo espectral de las estrellas (la mayoría), por eso se toma como criterio de filtro el tamaño de las estrellas.

Además se consideraran para la muesta solo los exoplanetas publicados en la literatura científica, por lo que se filtra por "Published Confirmed" en la columna `soltype`.


```{r filter_data}

library(dplyr)

# Seleccionar los sistemas con estrellas de tamaño
# similar al Sol (0.9 a 1.1 radios solares)
kepler_data <- kepler_data %>%
  filter(st_rad >= 0.9 & st_rad <= 1.1)

# Seleccionar solo los exoplanetas publicados en la literatura científica
kepler_data <- kepler_data %>%
  filter(soltype == "Published Confirmed")

# Eliminar columnas de referencias a sitios web
kepler_data <- kepler_data %>%
  select(-disc_refname, -pl_refname, -st_refname, -sy_refname)

# Eliminar columnas de id de catalogos externos de estrellas y sistemas
kepler_data <- kepler_data %>%
  select(-tic_id, -gaia_id, hostname, hd_name, hip_name)

# Eliminar información referente a la publicación del descubrimiento
# así como la información del instrumento utilizado, para todos es Kepler
kepler_data <- kepler_data %>%
  select(-disc_year, -disc_pubdate, -disc_locale, -disc_facility, -disc_telescope, -disc_instrument, -rowupdate, -pl_pubdate, -releasedate)

# Eliminar columnas con información referente a la detección
kepler_data <- kepler_data %>%
  select(-rv_flag, -pul_flag, -ptv_flag, -tran_flag, -ast_flag, -obm_flag, -micro_flag, -etv_flag, -ima_flag, dkin_flag)

# Eliminar columnas con información de fotometria
kepler_data <- kepler_data %>%
  select(-sy_bmag, -sy_vmag, -sy_jmag, -sy_hmag, -sy_kmag, -sy_umag, -sy_gmag, -sy_rmag, -sy_imag, -sy_zmag, -sy_w1mag, -sy_w2mag, -sy_w3mag, -sy_w4mag, -sy_gaiamag, -sy_icmag, -sy_tmag, -sy_kepmag)

# Eliminar banderas de organización interna del dataset
kepler_data <- kepler_data %>%
  select(-pl_nnotes, -pl_controv_flag, -default_flag)

# Eliminar columnas con información del sistema planetario
# y detalles técnicos de la detección
kepler_data <- kepler_data %>%
  select(-sy_mnum, -dkin_flag, -pl_ndispec)

# Eliminar columnas con información adicional de fotometria
kepler_data <- kepler_data %>%
  select(-st_nphot, -st_nrvc, -st_nspec, -pl_nespec, -pl_ntranspec)

```

El dataset resultante se guarda en un archivo CSV llamado `keplerfiltered.csv`. El dataset resultante contiene 2547 registros y 68 columnas.

Las columnas en el dataset filtrado, y su descripción extraída de https://exoplanetarchive.ipac.caltech.edu/docs/API_PS_columns.html, son las siguientes:

```{r show_filtered_data_structure, echo=FALSE}
library(dplyr)
library(knitr)

# Copiar el nombre de las columnas a un data frame
column_names <- data.frame(
  Column = names(kepler_data),
  stringsAsFactors = FALSE
)

# Agregar una columna con la descripción de la variable
# Fuente: https://exoplanetarchive.ipac.caltech.edu/docs/API_PS_columns.html
column_names <- column_names %>%
  mutate(Description = c(
    "pl_name: Nombre del planeta",
    "hostname: Nombre del sistema estelar utilizado en la literatura",
    "pl_letter: Letra del planeta en el sistema (primer planeta es b)",
    "hd_name: Nombre del sistema estelar en el catálogo Henry Draper",
    "hip_name: Nombre del sistema estelar en el catálogo Hipparcos",
    "sy_snum: Número de estrellas en el sistema",
    "sy_pnum: Número de planetas en el sistema",
    "cb_flag: Flag de circumbinario (el planeta orbita un sistema binario)",
    "discoverymethod: Método de descubrimiento del planeta",
    "soltype: Disposición del planeta según el conjunto de parámetros planetarios dado",
    "pl_orbper: Periodo orbital del planeta (en días)",
    "pl_orbsmax: Distancia orbital semieje mayor (en UA)",
    "pl_rade: Radio del planeta (en radios terrestres)",
    "pl_radj: Radio del planeta (en radios jovianos)",
    "pl_masse: Masa del planeta (en masas terrestres)",
    "pl_massj: Masa del planeta (en masas jovianas)",
    "pl_msinie: Mínimo de masa medida por el método de velocidad radial (en masas terrestres)",
    "pl_msinij: Mínimo de masa medida por el método de velocidad radial (en masas jovianas)",
    "pl_cmasse: Masa mínima proyectada (en masas terrestres)",
    "pl_cmassj: Masa mínima proyectada (en masas jovianas)",
    "pl_bmasse: Mejor estimación de la masa del planeta (en masas terrestres)",
    "pl_bmassj: Mejor estimación de la masa del planeta (en masas jovianas)",
    "pl_bmassprov: Proveedor de la mejor estimación de la masa del planeta (mínima o proyectada)",
    "pl_dens: Densidad del planeta (en g/cm³)",
    "pl_orbeccen: Excentricidad orbital del planeta",
    "pl_insol: Insolación del planeta en terminos la insolación de la tierra (en W/m²)",
    "pl_eqt: Temperatura de equilibrio del planeta considero como un cuerpo oscur (en grados K)",
    "pl_orbincl: Inclinación orbital del planeta respecto de la línea de visión desde la Tierra (en grados)",
    "pl_tranmid: Tiempo de tránsito medio del planeta respecto de su estrella (en días)",
    "pl_tsystemref: Sistema de Tiempo de Referencia del sistema planetario",
    "ttv_flag: Flag de tránsito de tiempo variante",
    "pl_imppar: Parámetro de impacto del planeta como distancia proyectada del centro del planeta al centro de la estrella (en radios estelares)",
    "pl_trandep: Profundidad del tránsito del planeta en terminos de el flujo relativo decreciente frente a su estrella (en %)",
    "pl_trandur: Duración del tránsito del planeta (en horas)",
    "pl_ratdor: cociente del semieje orbital mayor sobre el radio estelar",
    "pl_ratror: cociente del radio del planeta sobre el radio estelar",
    "pl_occdep: Profundidad del eclipse del planeta en terminos de el flujo relativo decreciente frente a su estrella (en %)",
    "pl_orbtper: El momento del paso del planeta por el periastro (en grados)",
    "pl_orblper: El argumento del periastro del planeta (en grados)",
    "pl_rvamp: Amplitud de la velocidad radial del planeta (en m/s)",
    "pl_projobliq: Inclinación proyectada del planeta respecto de la línea de visión desde la Tierra (en grados)",
    "pl_trueobliq: Inclinación verdadera del planeta respecto de la línea de visión desde la Tierra (en grados)",
    "st_spectype: Tipo espectral de la estrella según el sistema Morgan-Keenan",
    "st_teff: Temperatura efectiva de la estrella (en grados K)",
    "st_rad: Radio de la estrella (en radios solares)",
    "st_mass: Masa de la estrella (en masas solares)",
    "st_met: Medición del contenido de metales en la fotosfera de la estrella en comparación con el contenido de hidrógeno",
    "st_metratio: Relación de metalicidad de la estrella",
    "st_lum: Luminosidad de la estrella (en logartima en base 10 de unidades solares)",
    "st_logg: Gravedad superficial de la estrella (en logaritmo en base 10 de cm/s²)",
    "st_age: Edad de la estrella (en Ga, gigaaños, o miles de millones de años)",
    "st_dens: Densidad de la estrella (en g/cm³)",
    "st_vsin: Velocidad de rotación de la estrella (en km/s)",
    "st_rotp: Periodo de rotación de la estrella (en días)",
    "st_radv: Velocidad radial de la estrella (en km/s)",
    "rastr: Ascensión recta de la estrella (en grados sexagesimales)",
    "ra: Ascensión recta de la estrella (en grados decimales)",
    "decstr: Declinación de la estrella (en grados sexagesimales)",
    "dec: Declinación de la estrella (en grados decimales)",
    "glat: Latitud galáctica de la estrella (en grados decimales)",
    "glon: Longitud galáctica de la estrella (en grados decimales)",
    "elat: Latitud eclíptica de la estrella (en grados decimales)",
    "elon: Longitud eclíptica de la estrella (en grados decimales)",
    "sy_pm: Movimiento propio del sistema (en miliarcosegundos/año)",
    "sy_pmra: Movimiento propio del sistema en ascensión recta (en miliarcosegundos/año)",
    "sy_pmdec: Movimiento propio del sistema en declinación (en miliarcosegundos/año)",
    "sy_dist: Distancia del sistema (en parsecs)",
    "sy_plx: Paralaje del sistema (en miliarcosegundos)"))

# Ordenar el data frame por la columna "Column"
column_names <- column_names[order(column_names$Column), ]

# Eliminar de la columna Description el prefijo de la variable
column_names$Description <- gsub("^.*: ", "", column_names$Description)

# Elimina la columna con el numero de fila
rownames(column_names) <- NULL

kable(column_names, col.names = c("Variable", "Descripción"), align = "l")

```

```{r save_filtered_dataset, include=FALSE}
# Guardar los datos filtrados en un archivo CSV
write_csv(kepler_data, "keplerfiltered.csv")

# Guardar la estructura de las columnas en un archivo CSV
write_csv(column_names, "keplerdatadictionary.csv")
```

# Análisis Exploratorio de Datos

Para realizar un análisis exploratorio de los datos, se cargan el nuevo dataset y se realizan algunas visualizaciones y cálculos descriptivos.

```{r eda_filtered_data, echo=FALSE, message=FALSE, warning=FALSE}

library(ggplot2)
library(dplyr)
library(readr)
library(skimr)
library(knitr)

# Leer los datos completos
kepler_data <- read_csv("keplerfiltered.csv")

# Resumen de los datos con skimr solo variables numéricas
kepler_data_num <- kepler_data %>%
  select_if(is.numeric)

# Generar resumen con skimr 
resumen <- skim(kepler_data_num) 

# Ordenar por nombre de variable
resumen <- resumen[order(resumen$skim_variable), ]

# Filtrar columnas relevantes
resumen <- resumen %>%
  select(skim_variable, numeric.mean, numeric.sd, numeric.p0, numeric.p25, 
         numeric.p50, numeric.p75, numeric.p100, numeric.hist)

# Mostrar tabla formateada
kable(resumen, format = "markdown", digits = 4,
      col.names = c("Variable", "Media", "Des.Est.", "Mín.", "P25", "Mediana", "P75", "Máx.","Hist.")
      )

```

## Detención de Valores Faltantes

Se analiza la cantidad de valores faltantes en el dataset para identificar posibles problemas de calidad de datos.

```{r missing_values_calc}

library(tidyr)

# Calcular la cantidad de valores faltantes por columna
missing_values <- kepler_data %>%
  summarise_all(~sum(is.na(.))) %>%
  gather() %>%
  arrange(desc(value))

# Eliminar las columnas sin valores faltantes
missing_values <- missing_values %>%
  filter(value > 0)

# Total de columnas
total_rows <- nrow(missing_values)

# Calcular el punto medio
midpoint <- ceiling(total_rows / 2)

```

**Valores Faltantes por Columna**

```{r missing_values_graph1, echo=FALSE, message=FALSE, warning=FALSE}

ggplot(missing_values[1:midpoint,], aes(x = reorder(key, value), y = value)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "darkblue", width = 0.5) + # Reducir ancho de las barras
  geom_text(aes(label = value), hjust = -0.2, size = 3) + # Añadir valores al final de las barras
  coord_flip() +
  scale_y_continuous(expand = expansion(mult = c(0.01, 0.1))) + # Añadir margen extra en el eje y
  labs(title = "",
       x = "Columna",
       y = "") +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10),   # Ajustar tamaño de texto en eje Y
    plot.title = element_text(hjust = 0.5)  # Centrar el título
  )

```

```{r missing_values_graph2, echo=FALSE, message=FALSE, warning=FALSE}

# Crear un gráfico de barras con los valores faltantes que no sean cero
# con la segunda mitad de las filas
ggplot(missing_values[(midpoint+1):total_rows,], aes(x = reorder(key, value), y = value)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "darkblue", width = 0.5) + # Reducir ancho de las barras
  geom_text(aes(label = value), hjust = -0.2, size = 3) + # Añadir valores al final de las barras
  coord_flip() +
  scale_y_continuous(expand = expansion(mult = c(0.01, 0.1))) + # Añadir margen extra en el eje y
  labs(title = "",
       x = "",
       y = "Cantidad de Valores Faltantes") +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10),   # Ajustar tamaño de texto en eje Y
    plot.title = element_text(hjust = 0.5)  # Centrar el título
  )

```

Se detectan grandes cantidades valores faltantes en varias columnas del dataset, probablemente debido a la falta de estimaciones o mediciones para esos exoplanetas. Según los prefijos de columnas explicados en el detalle del dataset (<https://exoplanetarchive.ipac.caltech.edu/docs/API_PS_columns.html#planetparam>), se pueden identificar las siguientes categorías de variables:

-   `pl_`: Parámetros del planeta.
-   `st_`: Parámetros de la estrella.
-   `sy_`: Parámetros del sistema.

Buena parte de las variables faltantes corresponden a parámetros de los exoplanetas y sistemas, lo que puede dificultar el análisis y la predicción de la habitabilidad de los exoplanetas. Por lo tanto, se procederá a estimar los valores faltantes de aquellos parámetros en los que haya una cantidad suficiente de datos para realizar una estimación precisa.

El propósito de este trabajo es estimar los valores faltantes de los exoplanetas y predecir la habitabilidad de los mismos. Para ello, se utilizarán técnicas de regresión lineal y logística para estimar los valores faltantes y predecir la habitabilidad de los exoplanetas.

Tomando las variables conocida de los exoplanetas (parámetros con prefijo `pl_`), busca aquellas posibles predictoras de las variables faltantes. Por ejemplo para el caso del radio del exoplaneta (`pl_radj` en términos de radios jovianos y `pl_rade` en términos terrestres) con 886 faltantes, hay suficiente información para estimar el radio del exoplaneta a partir de otras variables conocidas como el periodo orbital en días (`pl_orbper` con 450 faltantes), el tiempo de conjunción (`pl_tranmid` con 675 faltantes) o el logaritmo en base 10 de gravedad superficial de la estrella en el centro del sistema planteario (`st_logg` con 554 faltantes).

Para saber cuál de estas variables es la mejor predictoras de la variable faltante, se utilizará la matriz de correlación para identificar las relaciones entre las variables numéricas del dataset con mayor correlación positiva o negativa con la variable faltante.

## Buscando Correlaciones

Se analiza la correlación entre las variables numéricas del dataset para identificar posibles relaciones entre ellas utilizando los métodos de Pearson (detección de correlaciones lineales).

```{r correlation_matrix_pearson, include=FALSE}

library(corrplot)

# Calcular la matriz de correlación
correlation_matrix_pearson <- cor(kepler_data_num, use="pairwise.complete.obs" , method = "pearson")

# Ordenar la matriz por nombre de columnas
correlation_matrix_pearson <- correlation_matrix_pearson[order(rownames(correlation_matrix_pearson)), order(colnames(correlation_matrix_pearson))]

# Número de variables
n_vars <- ncol(correlation_matrix_pearson)
half <- ceiling(n_vars / 2)

```

**Matriz de Correlación 1/3 (Pearson Cuadrante Superior)**

```{r plot_correlation_pearson_upper_quadrant, echo=FALSE}

# Parte 1: Primera mitad (diagonal superior)
correlation_matrix_pearson_sup <- correlation_matrix_pearson[1:half, 1:half]
corrplot(
  correlation_matrix_pearson_sup,
  method = "color",
  type = "upper",
  addCoef.col = "black",
  number.cex = 0.5,
  tl.cex = 0.7,
  tl.col = "black",
  col = colorRampPalette(c("indianred", "white", "steelblue"))(20),
  title = ""
)

```

**Matriz de Correlación 2/3 (Pearson Cruce)**

```{r plot_correlation_pearson_cross, echo=FALSE}

# Parte 2: Cruce entre la primera y segunda mitad
correlation_matrix_pearson_cross <- correlation_matrix_pearson[1:half, (half + 1):n_vars]
corrplot(
  correlation_matrix_pearson_cross,
  method = "color",
  type = "full",  # Mostrar todas las correlaciones en esta sección
  addCoef.col = "black",
  number.cex = 0.5,
  tl.cex = 0.7,
  tl.col = "black",
  col = colorRampPalette(c("indianred", "white", "steelblue"))(20),
  title = ""
)

```

**Matriz de Correlación 3/3 (Pearson Cuadrante Inferior)**

```{r plot_correlation_pearson_lower_quadrant, echo=FALSE}

# Parte 3: Segunda mitad (diagonal inferior)
correlation_matrix_pearson_inf <- correlation_matrix_pearson[(half + 1):n_vars, (half + 1):n_vars]
corrplot(
  correlation_matrix_pearson_inf,
  method = "color",
  type = "upper",
  addCoef.col = "black",
  number.cex = 0.5,
  tl.cex = 0.7,
  tl.col = "black",
  col = colorRampPalette(c("indianred", "white", "steelblue"))(20),
  title = ""
)

```

La matriz de correlación muestra las relaciones lineales entre las variables numéricas del dataset. Se observan algunas correlaciones positivas y negativas entre las variables, lo que indica posibles relaciones entre ellas. Por ejemplo el cociente entre el semieje orbital mayor y el periodo orbital (`pl_ratdor`) tiene una correlación positiva con el periodo orbital (`pl_orbper`) y una correlación negativa con la temperatura de equilibrio(`pl_eqt`). Respecto de la variable que se seleccionó como clase en el apartado anterior, el radio del exoplaneta (`pl_radj`) tiene una correlación positiva con la profundidad del tránsito (`pl_trandep`) y una correlación negativa con la gravedad superficial de la estrella (`st_logg`).

Para entender mejor la relación entre las variables con algo de correlación (umbral de 30% en valor absoluto) y seleccionar las mejores variables predictoras, se realiza un pair plot de las variables con mayor correlación positiva o negativa con la variable faltante. Se descartan como variables predictores aquellos que tengan más de 50% de valores faltantes.

``` {r most_correlated_variables, include=FALSE}

# Seleccionar de la matriz de correlación las variables con correlacion mayor o
# igual a 0.3 en valor absoluto con la variable faltante
correlated_vars <- names(which(abs(correlation_matrix_pearson["pl_radj", ]) >= 0.5))

# Se genera un dataframe con la correlacion entre las variables seleccionadas
# en correlated_vars y la variable faltante tomando de la matriz de correlacion
# solo las filas y columnas correspondientes a las variables seleccionadas
correlation_df <- data.frame(
  Variable = names(correlation_matrix_pearson[correlated_vars, "pl_radj"]),
  Correlacion = correlation_matrix_pearson[correlated_vars, "pl_radj"]
)

# Agregar una columna con la cantidad de valores faltantes
correlation_df$Faltantes <- sapply(correlation_df$Variable, function(x) sum(is.na(kepler_data[[x]])))

# Escribo a correlated_vars las variables seleccionadas
correlated_vars <- correlation_df$Variable

# Ordenar el dataframe por cantidad de faltantes ascendente
# y por valor absoluto de correlación descendente
correlation_df <- correlation_df[order(correlation_df$Faltantes, -abs(correlation_df$Correlacion)), ]

# Eliminar la columna de indice
rownames(correlation_df) <- NULL

# Mostrar tabla formateada
kable(correlation_df, columns = c("Variable","Correlación","Faltantes"), align = "l")

```

```{r pair_plot_correlated_variables, include=FALSE, warning=FALSE}

# pairs(kepler_data_num[correlated_vars], pch=19, cex=0.3, col = "red")

panel.hist <- function(x, ...) {
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5)) 
  hist(x, col = "indianred", border = "white", probability = TRUE, add = TRUE)
}

pairs(kepler_data_num[, correlated_vars], 
      diag.panel = panel.hist,     # Histogramas en la diagonal
      col = "steelblue", pch = 19, cex = 1.2)

```

Más allá de la correlación de la obvia relacion lineal entre el radio del exoplaneta en unidades jovianas y terrestres, parece haber una relación lineal entre el radio del exoplaneta y, en orden de correlación de las 3 primeras descendente, las siguientes variables:

- el cociente del radio planetario sobre el radio estelar (`pl_ratror`)
- la profundidad del tránsito del planeta (`pl_trandep`)
- la amplitud de la velocidad radial del planeta (`pl_rvamp`)

Se seleccionan como variables predictoras del radio del exploneta las variables con mayor correlación positiva o negativa que muestran una relación lineal con la variable faltante. 

# Detección de Valores Atípicos (Outliers)
Para las variables predictoras seleccionadas (`pl_ratdor`,`pl_trandep`,`pl_rvamp`), se detectan valores atípicos en el dataset que puedan afectar el análisis y la predicción de la variable faltante (`pl_radj`).

```{r outliers_detection, include=FALSE}

# Seleccionar las variables predictoras
predictor_vars <- c("pl_ratdor", "pl_trandep", "pl_rvamp")

# Crear un data frame con las variables predictoras
predictor_data <- kepler_data_num[predictor_vars]

# Normalizar los datos
predictor_data <- scale(predictor_data)

library(ggplot2)
library(tidyr)

predictor_data <- as.data.frame(predictor_data)

# Convertir a formato largo para ggplot2
data_long <- pivot_longer(predictor_data, cols = everything(), names_to = "Variable", values_to = "Valores")

# Graficar los valores atípicos con un boxplot
ggplot(data_long, aes(x = Variable, y = Valores)) +
  geom_boxplot(outlier.colour = "indianred", outlier.shape = 1, outlier.size = 2, width = 0.2, fill = "steelblue") +
  labs(title = "Boxplot de Variables predictoras",
       x = "Variable", y = "Valores") +
  coord_flip() +
  theme_minimal(base_size = 14)

```
Como puede observarse en el boxplot, las variables predictoras seleccionadas presentan valores atípicos que pueden afectar el análisis y la predicción de la variable faltante. Para tratar con esta situacié se puede considerar la utilización de métodos de regresión robustos que sean menos sensibles a los valores atípicos, como Huber. 

# Analisis de Regresión

Para analizar la relación entre las variables conocidas caracteristicas de los exoplanetas, se realiza un análisis de regresión lineal. La variable de dependiende `pl_radj` se intentará predecir a partir de las variables independientes:

- `pl_ratdor`
- `pl_trandep`
- `pl_rvamp`

## Regresión Lineal Univariada

Las variablies de características de los sistemas exoplanetarios tales como periodo orbital, radio planetario, temperatura de la estrella central del sistema y masa del planeta pueden inferirse indirectamente a partir de otras variables como excentricidad orbital, distancia a la estrella, caracteristicas de la estrella y otras. Se explorar un análisis de regresión lineal univariada con varias variables independientes evaluando la capacidad de predicción de cada modelo planteado.

Se realiza un análisis de regresión lineal univariada para predecir el radio del exoplaneta (`pl_radj`) consecutivamente a partir de las variables independientes seleccionadas.

```{r univar_reg_pl_ratdor}

# Regresion de pl_radj con pl_ratdor
model_pl_ratdor <- lm(pl_radj ~ pl_ratdor, data = kepler_data_num)

# Resumen del modelo
model_pl_ratdor_summary <- summary(model_pl_ratdor)

model_pl_ratdor_summary
```

```{r univar_reg_pl_ratdor_plot, warning=FALSE}

# Scatter plot de pl_radj vs pl_ratdor con la recta de regresión en rojo
# y los margenes de confianza en gris
ggplot(kepler_data_num, aes(x = pl_ratdor, y = pl_radj)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "lm", color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Regresión Lineal: Radio del Exoplaneta segun Ratio sobre el Radio Estelar",
       x = "Ratio sobre Radio Estelar",
       y = "Radio del Exoplaneta (Júpiter)") +
  theme_minimal()

```

```{r univar_reg_pl_ratdor_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_pl_ratdor <- residuals(model_pl_ratdor)

# Estimar los valores ajustados
fit_val_pl_ratdor <- fitted(model_pl_ratdor)

# Crear un data frame con los residuos y valores ajustados
res_pl_ratdor_df <- data.frame(Fitted_Values = fit_val_pl_ratdor, Residuals = res_pl_ratdor)

# Scatter plot de residuos vs valores ajustados
ggplot(res_pl_ratdor_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "indianred", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r univar_reg_pl_ratdor_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_pl_ratdor, main = "Gráfico Q-Q de los Residuos", col = "indianred")

```

```{r univar_reg_pl_ratdor_shapiro_test}

# Prueba de normalidad de Shapiro-Wilk
shapiro_test_pl_ratdor <- shapiro.test(res_pl_ratdor)

shapiro_test_pl_ratdor

```

```{r univar_reg_pl_ratdor_bp_test}

# Prueba de homocedasticidad de Breusch-Pagan
library(lmtest)

# Prueba de Breusch-Pagan
bp_test_pl_ratdor <- bptest(model_pl_ratdor)

bp_test_pl_ratdor

```

[Analisis sobre los resultados obtenidos]

Dado que el modelo de regresión lineal simple no es robusto a los valores atípicos, se analizar si una transformación logarítmica de las variables predictoras puede mejorar la capacidad predictiva del modelo mediante una prueba de Box-Cox.

```{r univar_reg_pl_ratdor_boxcox, warning=FALSE}

# Prueba de Box-Cox para transformar la variable st_rad
library(MASS)

# Prueba de Box-Cox
boxcox_pl_ratdor <- boxcox(model_pl_ratdor, lambda = seq(-2, 2, by = 0.1))

```
``` {r univar_reg_pl_ratdor_boxcox_optimal_lambda, warning=FALSE}

# Obtener el lambda óptimo
lambda_optimal <- boxcox_pl_ratdor$x[which.max(boxcox_pl_ratdor$y)]

lambda_optimal

```

El lambda óptimo es menor que 0 (-0.02020202), aunque muy cercano, una transformación logarítmica de la variable `pl_ratdor` podría mejorar la capacidad predictiva del modelo de regresión lineal simple. Se realiza una regresión lineal con la variable transformada y se evalúa la capacidad predictiva del modelo.


``` {r univar_reg_pl_ratdor_log, warning=FALSE}

# Regresión de pl_radj con log(pl_ratdor) 
model_pl_ratdor_log <- lm(pl_radj ~ log(pl_ratdor), data = kepler_data_num)

model_pl_ratdor_log_summary <- summary(model_pl_ratdor_log)

model_pl_ratdor_log_summary

```

```{r univar_reg_pl_ratdor_log_plot, warning=FALSE}

# Scatter plot de pl_radj vs log(pl_ratdor) con la recta de regresión en rojo
# y los margenes de confianza en gris
ggplot(kepler_data_num, aes(x = log(pl_ratdor), y = pl_radj)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "lm", color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Regresión Lineal: Radio del Exoplaneta segun Logaritmo del Ratio sobre el Radio Estelar",
       x = "Logaritmo del Ratio sobre Radio Estelar",
       y = "Radio del Exoplaneta (Júpiter)") +
  theme_minimal()

```
```{r univar_reg_pl_ratdor_log_res_plot, warning=FALSE}    

# Obtener los residuos y valores ajustados
res_pl_ratdor_log <- residuals(model_pl_ratdor_log)

# Calcular los valores ajustados
fit_val_pl_ratdor_log <- fitted(model_pl_ratdor_log)

# Crear un data frame con los residuos y valores ajustados
res_pl_ratdor_log_df <- data.frame(
  Residuals = res_pl_ratdor_log,
  Fitted_Values = fit_val_pl_ratdor_log
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_pl_ratdor_log_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "indianred", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r univar_reg_pl_ratdor_log_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_pl_ratdor_log, main = "Gráfico Q-Q de los Residuos", col="indianred")

```

```{r univar_reg_pl_trandep}

# Regresion del radio del exploplaneta (pl_radj) 
# con la profundidad del tránsito del planeta (pl_trandep)
# como predictor
model_pl_trandep <- lm(pl_radj ~ pl_trandep, data = kepler_data_num)

model_pl_trandep_summary <- summary(model_pl_trandep)

model_pl_trandep_summary

```

```{r univar_reg_pl_trandep_plot, warning=FALSE}

# Scatter plot de pl_radj vs pl_trandep con la recta de regresión en rojo
# y los margenes de confianza en gris
ggplot(kepler_data_num, aes(x = pl_trandep, y = pl_radj)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "lm", color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Regresión Lineal: Radio del Exoplaneta vs Profundidad del Tránsito",
       x = "Profundidad del Tránsito (%)",
       y = "Radio del Exoplaneta (Júpiter)") +
  theme_minimal()

```

```{r univar_reg_pl_trandep_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_pl_trandep <- residuals(model_pl_trandep)

# Calcular los valores ajustados
fit_val_pl_trandep <- fitted(model_pl_trandep)

# Crear un data frame con los residuos y valores ajustados
res_pl_trandep_df <- data.frame(
  Residuals = res_pl_trandep,
  Fitted_Values = fit_val_pl_trandep
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_pl_trandep_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "indianred", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r univar_reg_pl_trandep_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_pl_trandep, main = "Gráfico Q-Q de los Residuos", col="indianred")

```

```{r univar_reg_pl_trandep_shapiro_test}

# Prueba de normalidad de Shapiro-Wilk
shapiro_test_pl_trandep <- shapiro.test(res_pl_trandep)

shapiro_test_pl_trandep

```

```{r univar_reg_pl_trandep_bp_test}

# Prueba de homocedasticidad de Breusch-Pagan
library(lmtest)

# Prueba de Breusch-Pagan
bp_test_pl_trandep <- bptest(model_pl_trandep)

bp_test_pl_trandep

```
[Analisis sobre los resultados obtenidos]

Por detecarse un patron de U invertida en el scatter plot de los residuos vs valores ajustados, se puede inferir que la relación entre la variable dependiente y la independiente no es lineal. Se puede intentar ajustar un modelo polinómico de grado superior para mejorar la capacidad predictiva del modelo.

Dado que la variable independiente `pl_trandep` presenta muchos valores faltantes se imputarán los valores faltantes de la variable `pl_trandep` usando la mediana de la variable.

```{r univar_reg_pl_trandep_poly}

# Regresion del radio del exoplaneta (pl_radj)
# con la profundidad del tránsito del planeta (pl_trandep)
# como predictor

# copiar los datos en nuevo data frame
kepler_data_num_imputed <- kepler_data_num

# Imputar los valores faltantes de pl_trandep con la mediana
kepler_data_num_imputed$pl_trandep[is.na(kepler_data_num_imputed$pl_trandep)] <- median(kepler_data_num_imputed$pl_trandep, na.rm = TRUE)

# Ajustar un modelo polinómico de grado 2
model_pl_trandep_poly <- lm(pl_radj ~ poly(pl_trandep, 2), data = kepler_data_num_imputed)

model_pl_trandep_poly_summary <- summary(model_pl_trandep_poly)

model_pl_trandep_poly_summary

```
``` {r univar_reg_pl_trandep_poly_plot, warning=FALSE}

# Scatter plot de pl_radj vs pl_trandep con el polinomio de regresión en rojo
# y los margenes de confianza en gris
ggplot(kepler_data_num, aes(x = pl_trandep, y = pl_radj)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Regresión Polinómica: Radio del Exoplaneta vs Profundidad del Tránsito",
       x = "Profundidad del Tránsito (%)",
       y = "Radio del Exoplaneta (Júpiter)") +
  theme_minimal()

```
``` {r univar_reg_pl_trandep_poly_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_pl_trandep_poly <- residuals(model_pl_trandep_poly)

# Calcular los valores ajustados
fit_val_pl_trandep_poly <- fitted(model_pl_trandep_poly)

# Crear un data frame con los residuos y valores ajustados
res_pl_trandep_poly_df <- data.frame(
  Residuals = res_pl_trandep_poly,
  Fitted_Values = fit_val_pl_trandep_poly
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_pl_trandep_poly_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "indianred", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

``` {r univar_reg_pl_trandep_poly_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_pl_trandep_poly, main = "Gráfico Q-Q de los Residuos", col="indianred")

```

```{r univar_reg_pl_trandep_poly_shapiro_test}

# Prueba de normalidad de Shapiro-Wilk
shapiro_test_pl_trandep_poly <- shapiro.test(res_pl_trandep_poly)

shapiro_test_pl_trandep_poly

```

```{r univar_reg_pl_trandep_poly_bp_test}

# Prueba de homocedasticidad de Breusch-Pagan
library(lmtest)

# Prueba de Breusch-Pagan
bp_test_pl_trandep_poly <- bptest(model_pl_trandep_poly)

bp_test_pl_trandep_poly

```
[Analisis de los valores obtenidos]

```{r univar_reg_pl_rvamp}

# Regresion del radio del exoplaneta (pl_radj) 
# utilizando la amplitude de la velocidad radial del planeta (pl_rvamp)
# como predictor
model_pl_rvamp <- lm(pl_radj ~ pl_rvamp, data = kepler_data_num)

model_pl_rvamp_summary <- summary(model_pl_rvamp)

model_pl_rvamp_summary

```

```{r univar_reg_pl_rvamp_plot, warning=FALSE}

# Scatter plot de pl_radj vs pl_rvamp con la recta de regresión en rojo
# y los margenes de confianza en gris
ggplot(kepler_data_num, aes(x = pl_rvamp, y = pl_radj)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "lm", color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Regresión Lineal: Radio del Exoplaneta segun Amplitud de la Velocidad Radial",
       x = "Amplitud de la Velocidad Radial (ma/s)",
       y = "Radio del Exoplaneta (Júpiter)") +
  theme_minimal()

```

```{r univar_reg_pl_rvamp_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_pl_rvamp <- residuals(model_pl_rvamp)

# Calcular los valores ajustados
fit_val_pl_rvamp <- fitted(model_pl_rvamp)

# Crear un data frame con los residuos y valores ajustados
res_pl_rvamp_df <- data.frame(
  Residuals = res_pl_rvamp,
  Fitted_Values = fit_val_pl_rvamp
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_pl_rvamp_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "indianred", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r univar_pl_rvamp_eqt_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_pl_rvamp, main = "Gráfico Q-Q de los Residuos", col="indianred")

```

```{r univar_reg_pl_rvamp_shapiro_test}

# Prueba de normalidad de Shapiro-Wilk
shapiro_test_pl_rvamp <- shapiro.test(res_pl_rvamp)

shapiro_test_pl_rvamp

```

```{r univar_reg_pl_rvamp_rvamp_bp_test}

# Prueba de homocedasticidad de Breusch-Pagan
library(lmtest)

# Prueba de Breusch-Pagan
bp_test_pl_rvamp <- bptest(model_pl_rvamp)

bp_test_pl_rvamp

```

[Analisis sobre los resultados obtenidos]

## Regresión Lineal Multivariada

Se realiza un análisis de regresión lineal multivariada para predecir el radio del exoplaneta (`pl_radj`) simultaneamente a partir del cociente del radio planetario sobre el radio estelar (`pl_ratdor`), la profundiad del transito (`pl_trandep`) y la amplitud de la velocidad radial del planeta (`pl_rvamp`).

```{r multivar_reg}

# Regresion de pl_radj con pl_ratdor, pl_trandep y pl_rvamp
model_multivar <- lm(pl_radj ~ pl_ratdor + pl_trandep + pl_rvamp, data = kepler_data_num)

model_multivar_summary <- summary(model_multivar)

model_multivar_summary

```

```{r multivar_reg_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_multivar <- residuals(model_multivar)

# Calcular los valores ajustados
fit_val_multivar <- fitted(model_multivar)

# Crear un data frame con los residuos y valores ajustados
res_multivar_df <- data.frame(
  Residuals = res_multivar,
  Fitted_Values = fit_val_multivar
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_multivar_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "indianred", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r multivar_reg_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_multivar, main = "Gráfico Q-Q de los Residuos", col="indianred")

```

```{r multivar_reg_shapiro_test}

# Prueba de normalidad de Shapiro-Wilk
shapiro_test_multivar <- shapiro.test(res_multivar)

shapiro_test_multivar

```

```{r multivar_reg_bp_test}

# Prueba de homocedasticidad de Breusch-Pagan
library(lmtest)

# Prueba de Breusch-Pagan
bp_test_multivar <- bptest(model_multivar)

bp_test_multivar

```
[Analisis de los resultados obtenidos]

## Regresión Logística

Para predecir la habitabilidad de los exoplanetas, se realiza un análisis de regresión logística utilizando las variables conocidas de los exoplanetas y las estrellas del sistema. Se seleccionan las variables conocidas de los exoplanetas y las estrellas como variables independientes y la habitabilidad como variable dependiente.

Existen varios indicadores de habitabilidad de los exoplanetas. Considerando que estamos estudiando estrellas con radios similiares al solar (+/- 10%) los parámetros planetarios más relevantes son:

-La temperatura de equilibrio (`pl_eqt`) por ser una variable fundamental en la definición de la zona habitable, ya que está directamente relacionada con la posibilidad de agua líquida en la superficie de un planeta. En https://iopscience.iop.org/article/10.1088/0004-637X/765/2/131 analiza factores para ajustar los límites de la zona habitable y define los rangos ideales de temperatura para habitabilidad.
- La insolación (`pl_insol`), esto es flujo de radiación recibido por el planeta en comparación con la Tierra, es otro predictor clave, ya que determina el balance energético del planeta. En https://arxiv.org/abs/1610.05765 se estudia los efectos del flujo de radiación en la zona habitable y su impacto en la capacidad de un planeta para retener agua.
- El semieje mayor orbital (`pl_orbsmax`) es otro indicador importante, ya que determina la distancia del planeta a su estrella anfitriona y, por lo tanto, su temperatura superficial. En https://arxiv.org/abs/1205.2429 se demuestra cómo la distancia orbital y la luminosidad de la estrella afectan la habitabilidad.

La determinación de la habitabilidad de un exoplaneta es un tema complejo y multifactorial que depende de varios indicadores físicos y químicos. Si bien no existe una fórmula única universalmente aceptada para calcular la "habitabilidad", se pueden combinar los indicadores antes mencionados para aproximar el potencial de habitabilidad de un exoplaneta. Una de las aproximaciones más comunes es usar una combinación ponderada de las condiciones adecuadas para la presencia de agua líquida, ya que esta es fundamental para la vida tal como la conocemos. El uso de una combinación lineal ponderada de  variables tales como las consideradas es una técnica válida en la modelización de habitabilidad planetaria. En https://www.researchgate.net/publication/353861442_Habitability_Models_for_Astrobiology se propone el Earth Similarity Index (ESI), que usa una fórmula normalizada combinando temperatura, flujo estelar y parámetros orbitales.

Así con los indicadores seleccionados definimos un Índice de Habitabilidad Planetaria (PHI - Planetary Habitability Index) como una función normalizada que combine los indicadores clave:

$$
\text{PHI} = w_1 \cdot f_1(\text{pl_eqt}) + w_2 \cdot f_2(\text{pl_insol}) + w_3 \cdot f_3(\text{pl_orbsmax}) 
$$ 
Donde:

-   $w_i$ son los pesos normalizados asociados a cada indicador sumando 1.
-   $f_i(x)$ son funciones de transformación o normalización que convierten las medidas en valores entre 0 y 1, según el rango de habitabilidad conocido.

Estas variables se consideran como posibles predictores de la habitabilidad de los exoplanetas cuando están en determinados rangos.

**Temperatura de equilibrio** (`pl_eqt`): Idealmente, debe estar en un rango compatible con agua líquida, aproximadamente entre 0°C y 100°C. Así la normalización resultan en:

$$
f_i(\text{pl_eqt}) = \max\left(0, \min\left(1, \frac{\text{pl_eqt} - T_{\text{min}}}{T_{\text{max}} - T_{\text{min}}}\right)\right)
$$ 

Donde $T_{\text{min}}$ y $T_{\text{max}}$ son los límites inferiores y superiores. El agua líquida, esencial para la vida, puede existir en un rango de temperaturas superficiales de aproximadamente 273K (0 °C) a 373K (100 °C). Sin embargo, debido a factores atmosféricos y de presión, este rango puede extenderse ligeramente: $T_{\text{min}}=200K$ puede ser el umbral inferior, considerando atmósferas densas como la de Marte y $T_{\text{max}}=400K$ puede considerarse el umbral superior, considerando atmósferas con alta presión como la de Venus.

Según la literatura especializada el peso de la temperatura de equilibrio en el índice de habitabilidad es de $w_1=0.40$ cuando se considera la temperatura de equilibrio como un indicador preponderante de habitabilidad y no se tienen muchos más datos del planeta.

**Insolación** (`pl_insol`): La insolación es la cantidad de energía recibida por el planeta y es un indicador importante de la habitabilidad. La insolación se mide en unidades de flujo de energía recibida por unidad de área y se puede normalizar en un rango de 0 a 1. La insolación ideal para la vida es aquella que permite la presencia de agua líquida en la superficie del planeta (generalmente valores cercanos a la Tierra son ideales). La insolación se puede normalizar considerando que La Tierra tiene una insolación de 1S (donde $S$ es la insolación solar a la distancia de la Tierra) y se puede considerar que la vida puede existir en un rango de insolación de $I_{min}=0.3S$ (aproximadamente el límite interior de la zona habitable para una estrella como el Sol, más allá de este valor el agua podría congelarse) a $I_{max}=1,7S$ (aproximadamente el límite exterior de la zona habitable, más allá de este valor el agua podría evaporarse). Así la normalización resulta en:

$$
f_2(\text{pl_insol}) = \max\left(0, \min\left(1, \frac{\text{pl_insol} - I_{\text{min}}}{I_{\text{max}} - I_{\text{min}}}\right)\right)
$$

La insolación es un factor crítico para mantener agua líquida en la superficie del planeta, pero su impacto depende de otros factores como la atmósfera y el albedo, según la literatura especializada el peso de la insolación en el índice de habitabilidad es de $w_2=0.30$. Es importante destacar que El rango de $I_{min}$ e $I_{max}$ puede variar según la luminosidad de la estrella, ya que la zona habitable cambia en función del tipo estelar por lo que esta estimación sirve para estrellas similares al Sol.

**Distancia orbital semieje mayor** (`pl_orbsmax`): La distancia orbital semieje mayor es un indicador de la zona habitable de un sistema planetario. La distancia orbital semieje mayor se mide en unidades astronómicas (UA) y se puede normalizar en un rango de 0 a 1. La distancia orbital semieje mayor ideal para la vida es aquella que permite la presencia de agua líquida en la superficie del planeta. La distancia orbital semieje mayor se puede normalizar considerando que La Tierra tiene una distancia orbital semieje mayor de 1 UA y se puede considerar que la vida puede existir en un rango de distancias de $D_{\text{min}}=0,5$ UA (aproximadamente el límite interior de la zona habitable para una estrella como el Sol, más allá de este valor el agua podría congelarse) a $D_{\text{max}}=2$ UA (aproximadamente el límite exterior de la zona habitable, más allá de este valor el agua podría evaporarse). Estos rangos pueden variar según el tipo de estrella. Así la normalización resulta en:

$$
f_3(\text{pl_orbsmax}) = \max\left(0, \min\left(1, \frac{\text{pl_orbsmax} - D_{\text{min}}}{D_{\text{max}} - D_{\text{min}}}\right)\right)
$$ 

En la mayoría de los modelos, el peso para el valor normalizado de `pl_orbsmax` oscila entre 15% y 25%. Esto se debe a que `pl_orbsmax` complementa indicadores más directos como `pl_eqt` (temperatura de equilibrio) y `pl_insol` (insolación). Se tomará un peso de $w_3=0.30$.

Por lo tanto el índice de habitabilidad planetaria (PHI) con variables normalizadas y sus respectivos pesos es:

$$
\text{PHI} = 0.4 \cdot f_1(\text{pl_eqt}) + 0.3 \cdot f_2(\text{pl_insol}) + 0,3 \cdot f_3(\text{pl_orbsmax}) 
$$ 


```{r log_reg}

library(dplyr)

# Crear un data frame con las variables seleccionadas
kepler_data_logistic <- kepler_data %>%
  dplyr::select(pl_eqt, pl_insol, pl_orbsmax)

# Normalizar las variables
kepler_data_logistic_normalized <- kepler_data_logistic %>%
  mutate(
    pl_eqt_normalized = pmin(1, pmax(0, (pl_eqt - 200) / (400 - 200))),
    pl_insol_normalized = pmin(1, pmax(0, (pl_insol - 0.3) / (1.7 - 0.3))),
    pl_orbsmax_normalized = pmin(1, pmax(0, (pl_orbsmax - 0.05) / (2 - 1.05)))
  )

# Calcular el índice de habitabilidad planetaria (PHI)
kepler_data_logistic_normalized <- kepler_data_logistic_normalized %>%
  mutate(
    phi = 0.4 * pl_eqt_normalized + 0.3 * pl_insol_normalized + 0.3 * pl_orbsmax_normalized 
  )

# Remover columnas no normalizadas
kepler_data_logistic_normalized <- subset(kepler_data_logistic_normalized, select = -c(pl_eqt, pl_insol, pl_orbsmax))

# Crear un modelo de regresión logística
model_logistic <- glm(phi ~ ., data = kepler_data_logistic_normalized, family = binomial)

model_logistic_summary <- summary(model_logistic)

model_logistic_summary

```
```{r log_reg_plot, warning=FALSE}

# Graficar la curva logistica del modelo
# Crear un data frame con los valores de PHI y las probabilidades predichas
# de habitabilidad. Seleccionar solo los registros donde se conoce la habitabilidad
phi_prob <- predict(model_logistic, type = "response")

# Filtrar los registros donde se conoce la habitabilidad
kepler_data_logistic_normalized <- kepler_data_logistic_normalized %>%
  filter(!is.na(phi))

phi_prob_df <- data.frame(PHI = kepler_data_logistic_normalized$phi, Probabilidad = phi_prob)

# Scatter plot de PHI vs Probabilidad
ggplot(phi_prob_df, aes(x = PHI, y = Probabilidad)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "glm", method.args = list(family = "binomial"), color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Curva Logística del Modelo de Regresión",
       x = "PHI",
       y = "Probabilidad") +
  theme_minimal()

```
El modelo de regresión logística resultante no es muy bueno por la poca cantidad de datos que se tienen de exoplanetas para calcular el PHI: solo se tienen 17 exoplanetas con datos completos de temperatura de equilibrio, insolación y semieje mayor orbital. 
