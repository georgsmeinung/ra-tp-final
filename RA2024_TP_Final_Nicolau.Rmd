::: {style="text-align: center;"}
![](logo-austral.png){width="200px"}
:::

---
title: "Regresión Avanzada 2024"
subtitle: "Trabajo Práctico Final"
author: "Jorge Nicolau"
output:
   html_document:
     toc: true
     code_folding: show
     toc_float: false
     df_print: paged
     theme: united
     code_download: true
     toc_depth: 2
editor_options: 
  markdown: 
    wrap: none
---

```{r setup, include=FALSE}
# Limpieza del Workspace
rm(list = ls())

# Determinar el directorio del script actual
# y cambiar el working directory al directorio del script actual
library(rstudioapi)
script_full_path <- rstudioapi::getSourceEditorContext()$path
script_path <- file.path(dirname(script_full_path), "")
setwd(script_path)

knitr::opts_chunk$set(echo = TRUE)
# Deshabilita la impresión de tus resultados en notación científica
options(scipen=999)
```

# Preprocesamiento de Datos

El dataset de exoplanetas detectados por la misión Kepler contiene información sobre 28.217 exoplanetas (entre confirmados y propuetos) y sus características. El objetivo de este trabajo es preprocesar los datos para realizar un análisis exploratorio y utilizar regresión linea y logística para la extracción de paramétros faltantes de los exoplanetas y para predecir la habitabilidad de los mismos.

Se cargarán los datos, se filtrarán las filas de los explonetas confirmados, las columnas relevantes, se eliminarán los valores faltantes y se realizará un análisis exploratorio de los datos.

## Carga de Datos

Se cargan los datos del dataset de exoplanetas de la misión Kepler del archivo `keplerexoplanets.csv`. El mismo se obtuvo de la página del IPAC del Caltech (<https://exoplanetarchive.ipac.caltech.edu/cgi-bin/TblView/nph-tblView?app=ExoTbls&config=PS>) y contiene información sobre los sistemas exoplanetaarios detectados por la misión Kepler (<https://science.nasa.gov/mission/kepler/>).

```{r load_data, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
library(readr)

# Cargar los datos
kepler_data <- read_csv("keplerexoplanets.csv")
```

**Estructura de los Datos**

```{r show_data_str, echo=FALSE}

library(knitr)

# Capturar la salida de str() como texto
str_output <- capture.output(str(kepler_data, list.len = Inf, give.attr=FALSE))

# Convertir la salida en un data frame para formatearla como tabla
str_df <- data.frame(
  Details = str_output,
  stringsAsFactors = FALSE
)

# Mostrar la salida en formato de tabla con kable
kable(str_df, col.names = c("Tipo de datos y previsualización"), align = "l")

```

Se eliman las columnas con referencias a sitios web no relevantes para el análisis. También se eliminan los datos de referencia de los planetas, estrellas y sistemas no relevantes para el análisis.

Por último, para determina la habitabilidad de los exoplanetas es necesario conocer el tipo espectral de la estrella central del sistema. Por lo tanto, se eliminan los sistemas con tipo espectral desconocido.

```{r filter_data}

library(dplyr)

# Eliminar los sistemas con tipo espectrales desconocidos (NA)
kepler_data <- kepler_data %>%
  filter(!is.na(st_spectype))

# Eliminar columnas de referencias a sitios web
kepler_data <- kepler_data %>%
  select(-disc_refname, -pl_refname, -st_refname, -sy_refname)

# Eliminar columnas de id de catalogos externos de estrellas y sistemas
kepler_data <- kepler_data %>%
  select(-tic_id, -gaia_id, hostname, hd_name, hip_name)

# Eliminar información referente a la publicación del descubrimiento
# así como la información del instrumento utilizado, para todos es Kepler
kepler_data <- kepler_data %>%
  select(-disc_year, -disc_pubdate, -disc_locale, -disc_facility, -disc_telescope, -disc_instrument, -rowupdate, -pl_pubdate, -releasedate)

# Eliminar columnas con información referente a la detección
kepler_data <- kepler_data %>%
  select(-rv_flag, -pul_flag, -ptv_flag, -tran_flag, -ast_flag, -obm_flag, -micro_flag, -etv_flag, -ima_flag, dkin_flag)

# Eliminar columnas con información de fotometria
kepler_data <- kepler_data %>%
  select(-sy_bmag, -sy_vmag, -sy_jmag, -sy_hmag, -sy_kmag, -sy_umag, -sy_gmag, -sy_rmag, -sy_imag, -sy_zmag, -sy_w1mag, -sy_w2mag, -sy_w3mag, -sy_w4mag, -sy_gaiamag, -sy_icmag, -sy_tmag, -sy_kepmag)

# Eliminar banderas de organización interna del dataset
kepler_data <- kepler_data %>%
  select(-pl_nnotes, -pl_controv_flag, -default_flag)

# Eliminar columnas con información del sistema planetario
# y detalles técnicos de la detección
kepler_data <- kepler_data %>%
  select(-sy_mnum, -dkin_flag, -pl_ndispec)

# Eliminar columnas con información adicional de fotometria
kepler_data <- kepler_data %>%
  select(-st_nphot, -st_nrvc, -st_nspec, -pl_nespec, -pl_ntranspec)

```

El dataset resultante se guarda en un archivo CSV llamado `keplerfiltered.csv`. El dataset resultante contiene 182 registros y 68 columnas.

Las columnas en el dataset filtrado, y su descripción extraída de https://exoplanetarchive.ipac.caltech.edu/docs/API_PS_columns.html,  son las siguientes:

```{r show_filtered_data_structure, echo=FALSE}
library(dplyr)
library(knitr)

# Copiar el nombre de las columnas a un data frame
column_names <- data.frame(
  Column = names(kepler_data),
  stringsAsFactors = FALSE
)

# Agregar una columna con la descripción de la variable
# Fuente: https://exoplanetarchive.ipac.caltech.edu/docs/API_PS_columns.html
column_names <- column_names %>%
  mutate(Description = c(
    "pl_name: Nombre del planeta",
    "hostname: Nombre del sistema estelar utilizado en la literatura",
    "pl_letter: Letra del planeta en el sistema (primer planeta es b)",
    "hd_name: Nombre del sistema estelar en el catálogo Henry Draper",
    "hip_name: Nombre del sistema estelar en el catálogo Hipparcos",
    "sy_snum: Número de estrellas en el sistema",
    "sy_pnum: Número de planetas en el sistema",
    "cb_flag: Flag de circumbinario (el planeta orbita un sistema binario)",
    "discoverymethod: Método de descubrimiento del planeta",
    "soltype: Disposición del planeta según el conjunto de parámetros planetarios dado",
    "pl_orbper: Periodo orbital del planeta (en días)",
    "pl_orbsmax: Distancia orbital semieje mayor (en UA)",
    "pl_rade: Radio del planeta (en radios terrestres)",
    "pl_radj: Radio del planeta (en radios jovianos)",
    "pl_masse: Masa del planeta (en masas terrestres)",
    "pl_massj: Masa del planeta (en masas jovianas)",
    "pl_msinie: Mínimo de masa medida por el método de velocidad radial (en masas terrestres)",
    "pl_msinij: Mínimo de masa medida por el método de velocidad radial (en masas jovianas)",
    "pl_cmasse: Masa mínima proyectada (en masas terrestres)",
    "pl_cmassj: Masa mínima proyectada (en masas jovianas)",
    "pl_bmasse: Mejor estimación de la masa del planeta (en masas terrestres)",
    "pl_bmassj: Mejor estimación de la masa del planeta (en masas jovianas)",
    "pl_bmassprov: Proveedor de la mejor estimación de la masa del planeta (mínima o proyectada)",
    "pl_dens: Densidad del planeta (en g/cm³)",
    "pl_orbeccen: Excentricidad orbital del planeta",
    "pl_insol: Insolación del planeta en terminos la insolación de la tierra (en W/m²)",
    "pl_eqt: Temperatura de equilibrio del planeta considero como un cuerpo oscur (en grados K)",
    "pl_orbincl: Inclinación orbital del planeta respecto de la línea de visión desde la Tierra (en grados)",
    "pl_tranmid: Tiempo de tránsito medio del planeta respecto de su estrella (en días)",
    "pl_tsystemref: Sistema de Tiempo de Referencia del sistema planetario",
    "ttv_flag: Flag de tránsito de tiempo variante",
    "pl_imppar: Parámetro de impacto del planeta como distancia proyectada del centro del planeta al centro de la estrella (en radios estelares)",
    "pl_trandep: Profundidad del tránsito del planeta en terminos de el flujo relativo decreciente frente a su estrella (en %)",
    "pl_trandur: Duración del tránsito del planeta (en horas)",
    "pl_ratdor: cociente del semieje orbital mayor sobre el radio estelar",
    "pl_ratror: cociente del radio del planeta sobre el radio estelar",
    "pl_occdep: Profundidad del eclipse del planeta en terminos de el flujo relativo decreciente frente a su estrella (en %)",
    "pl_orbtper: El momento del paso del planeta por el periastro (en grados)",
    "pl_orblper: El argumento del periastro del planeta (en grados)",
    "pl_rvamp: Amplitud de la velocidad radial del planeta (en m/s)",
    "pl_projobliq: Inclinación proyectada del planeta respecto de la línea de visión desde la Tierra (en grados)",
    "pl_trueobliq: Inclinación verdadera del planeta respecto de la línea de visión desde la Tierra (en grados)",
    "st_spectype: Tipo espectral de la estrella según el sistema Morgan-Keenan",
    "st_teff: Temperatura efectiva de la estrella (en grados K)",
    "st_rad: Radio de la estrella (en radios solares)",
    "st_mass: Masa de la estrella (en masas solares)",
    "st_met: Medición del contenido de metales en la fotosfera de la estrella en comparación con el contenido de hidrógeno",
    "st_metratio: Relación de metalicidad de la estrella",
    "st_lum: Luminosidad de la estrella (en logartima en base 10 de unidades solares)",
    "st_logg: Gravedad superficial de la estrella (en logaritmo en base 10 de cm/s²)",
    "st_age: Edad de la estrella (en Ga, gigaaños, o miles de millones de años)",
    "st_dens: Densidad de la estrella (en g/cm³)",
    "st_vsin: Velocidad de rotación de la estrella (en km/s)",
    "st_rotp: Periodo de rotación de la estrella (en días)",
    "st_radv: Velocidad radial de la estrella (en km/s)",
    "rastr: Ascensión recta de la estrella (en grados sexagesimales)",
    "ra: Ascensión recta de la estrella (en grados decimales)",
    "decstr: Declinación de la estrella (en grados sexagesimales)",
    "dec: Declinación de la estrella (en grados decimales)",
    "glat: Latitud galáctica de la estrella (en grados decimales)",
    "glon: Longitud galáctica de la estrella (en grados decimales)",
    "elat: Latitud eclíptica de la estrella (en grados decimales)",
    "elon: Longitud eclíptica de la estrella (en grados decimales)",
    "sy_pm: Movimiento propio del sistema (en miliarcosegundos/año)",
    "sy_pmra: Movimiento propio del sistema en ascensión recta (en miliarcosegundos/año)",
    "sy_pmdec: Movimiento propio del sistema en declinación (en miliarcosegundos/año)",
    "sy_dist: Distancia del sistema (en parsecs)",
    "sy_plx: Paralaje del sistema (en miliarcosegundos)"))

# Ordenar el data frame por la columna "Column"
column_names <- column_names[order(column_names$Column), ]

# Eliminar de la columna Description el prefijo de la variable
column_names$Description <- gsub("^.*: ", "", column_names$Description)

# Elimina la columna con el numero de fila
rownames(column_names) <- NULL

kable(column_names, col.names = c("Variable", "Descripción"), align = "l")

```

```{r save_filtered_dataset, include=FALSE}
# Guardar los datos filtrados en un archivo CSV
write_csv(kepler_data, "keplerfiltered.csv")

# Guardar la estructura de las columnas en un archivo CSV
write_csv(column_names, "keplerdatadictionary.csv")
```

# Análisis Exploratorio de Datos

Para realizar un análisis exploratorio de los datos, se cargan el nuevo dataset y se realizan algunas visualizaciones y cálculos descriptivos.

```{r eda_filtered_data, echo=FALSE, message=FALSE, warning=FALSE}

library(ggplot2)
library(dplyr)
library(readr)
library(skimr)
library(knitr)

# Leer los datos completos
kepler_data <- read_csv("keplerfiltered.csv")

# Resumen de los datos con skimr solo variables numéricas
kepler_data_num <- kepler_data %>%
  select_if(is.numeric)

# Generar resumen con skimr 
resumen <- skim(kepler_data_num) 

# Ordenar por nombre de variable
resumen <- resumen[order(resumen$skim_variable), ]

# Filtrar columnas relevantes
resumen <- resumen %>%
  select(skim_variable, numeric.mean, numeric.sd, numeric.p0, numeric.p25, 
         numeric.p50, numeric.p75, numeric.p100, numeric.hist)

# Mostrar tabla formateada
kable(resumen, format = "markdown", digits = 4,
      col.names = c("Variable", "Media", "Des.Est.", "Mín.", "P25", "Mediana", "P75", "Máx.","Hist.")
      )

```

## Detención de Valores Faltantes

Se analiza la cantidad de valores faltantes en el dataset para identificar posibles problemas de calidad de datos.

```{r missing_values_calc}

library(tidyr)

# Calcular la cantidad de valores faltantes por columna
missing_values <- kepler_data %>%
  summarise_all(~sum(is.na(.))) %>%
  gather() %>%
  arrange(desc(value))

# Eliminar las columnas sin valores faltantes
missing_values <- missing_values %>%
  filter(value > 0)

# Crear un gráfico de barras con los valores faltantes que no sean cero
# con la primera mitad de las filas

# Total de columnas
total_rows <- nrow(missing_values)

# Calcular el punto medio
midpoint <- ceiling(total_rows / 2)

```

**Valores Faltantes por Columna**

```{r missing_values_graph1, echo=FALSE, message=FALSE, warning=FALSE}

ggplot(missing_values[1:midpoint,], aes(x = reorder(key, value), y = value)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "darkblue", width = 0.5) + # Reducir ancho de las barras
  geom_text(aes(label = value), hjust = -0.2, size = 3) + # Añadir valores al final de las barras
  coord_flip() +
  scale_y_continuous(expand = expansion(mult = c(0.01, 0.1))) + # Añadir margen extra en el eje y
  labs(title = "",
       x = "Columna",
       y = "") +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10),   # Ajustar tamaño de texto en eje Y
    plot.title = element_text(hjust = 0.5)  # Centrar el título
  )

```

```{r missing_values_graph2, echo=FALSE, message=FALSE, warning=FALSE}

# Crear un gráfico de barras con los valores faltantes que no sean cero
# con la segunda mitad de las filas
ggplot(missing_values[(midpoint+1):total_rows,], aes(x = reorder(key, value), y = value)) +
  geom_bar(stat = "identity", fill = "skyblue", color = "darkblue", width = 0.5) + # Reducir ancho de las barras
  geom_text(aes(label = value), hjust = -0.2, size = 3) + # Añadir valores al final de las barras
  coord_flip() +
  scale_y_continuous(expand = expansion(mult = c(0.01, 0.1))) + # Añadir margen extra en el eje y
  labs(title = "",
       x = "",
       y = "Cantidad de Valores Faltantes") +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10),   # Ajustar tamaño de texto en eje Y
    plot.title = element_text(hjust = 0.5)  # Centrar el título
  )

```

Se detectan grandes cantidades valores faltantes en varias columnas del dataset, probablemente debido a la falta de estimaciones o mediciones para esos exoplanetas. Según los prefijos de columnas explicados en el detalle del dataset (<https://exoplanetarchive.ipac.caltech.edu/docs/API_PS_columns.html#planetparam>), se pueden identificar las siguientes categorías de variables:

-   `pl_`: Parámetros del planeta.
-   `st_`: Parámetros de la estrella.
-   `sy_`: Parámetros del sistema.

Buena parte de las variables faltantes corresponden a parámetros de los exoplanetas y sistemas, lo que puede dificultar el análisis y la predicción de la habitabilidad de los exoplanetas. Por lo tanto, se procederá a estimar los valores faltantes de aquellos parámetros en los que haya una cantidad suficiente de datos para realizar una estimación precisa.

El propósito de este trabajo es estimar los valores faltantes de los exoplanetas y predecir la habitabilidad de los mismos. Para ello, se utilizarán técnicas de regresión lineal y logística para estimar los valores faltantes y predecir la habitabilidad de los exoplanetas.

Tomando las variables conocida de los exoplanetas (parámetros con prefijo `pl_`), busca aquellas posibles predictoras de las variables faltantes. Por ejemplo para el caso del radio del exoplaneta (`pl_radj` en términos de radios jovianos y `pl_rade` en términos terrestres) con 11 faltantes, hay suficiente información para estimar el radio del exoplaneta a partir de otras variables conocidas como el periodo orbital en días (`pl_orbper` con 147 faltantes), el tiempo de conjunción (`pl_tranmid` con 80 faltantes) o el logaritmo en base 10 de gravedad superficial de la estrella en el centro del sistema planteario (`st_logg` con 96 faltantes).

Para saber cuál de estas variables es la mejor predictoras de la variable faltante, se utilizará la matriz de correlación para identificar las relaciones entre las variables numéricas del dataset con mayor correlación positiva o negativa con la variable faltante.

## Buscando Correlaciones

Se analiza la correlación entre las variables numéricas del dataset para identificar posibles relaciones entre ellas utilizando los métodos de Pearson (detección de correlaciones lineales).

```{r correlation_matrix_pearson, include=FALSE}

library(corrplot)

# Calcular la matriz de correlación
correlation_matrix_pearson <- cor(kepler_data_num, use="pairwise.complete.obs" , method = "pearson")

# Ordenar la matriz por nombre de columnas
correlation_matrix_pearson <- correlation_matrix_pearson[order(rownames(correlation_matrix_pearson)), order(colnames(correlation_matrix_pearson))]

# Número de variables
n_vars <- ncol(correlation_matrix_pearson)
half <- ceiling(n_vars / 2)

```

**Matriz de Correlación 1/3 (Pearson Cuadrante Superior)**

```{r plot_correlation_pearson_upper_quadrant, echo=FALSE}

# Parte 1: Primera mitad (diagonal superior)
correlation_matrix_pearson_sup <- correlation_matrix_pearson[1:half, 1:half]
corrplot(
  correlation_matrix_pearson_sup,
  method = "color",
  type = "upper",
  addCoef.col = "black",
  number.cex = 0.3,
  tl.cex = 0.5,
  tl.col = "black",
  col = colorRampPalette(c("indianred", "white", "steelblue"))(20),
  title = ""
)

```

**Matriz de Correlación 2/3 (Pearson Cruce)**

```{r plot_correlation_pearson_cross, echo=FALSE}

# Parte 2: Cruce entre la primera y segunda mitad
correlation_matrix_pearson_cross <- correlation_matrix_pearson[1:half, (half + 1):n_vars]
corrplot(
  correlation_matrix_pearson_cross,
  method = "color",
  type = "full",  # Mostrar todas las correlaciones en esta sección
  addCoef.col = "black",
  number.cex = 0.3,
  tl.cex = 0.5,
  tl.col = "black",
  col = colorRampPalette(c("indianred", "white", "steelblue"))(20),
  title = ""
)

```

**Matriz de Correlación 3/3 (Pearson Cuadrante Inferior)**

```{r plot_correlation_pearson_lower_quadrant, echo=FALSE}

# Parte 3: Segunda mitad (diagonal inferior)
correlation_matrix_pearson_inf <- correlation_matrix_pearson[(half + 1):n_vars, (half + 1):n_vars]
corrplot(
  correlation_matrix_pearson_inf,
  method = "color",
  type = "upper",
  addCoef.col = "black",
  number.cex = 0.3,
  tl.cex = 0.5,
  tl.col = "black",
  col = colorRampPalette(c("indianred", "white", "steelblue"))(20),
  title = ""
)

```

La matriz de correlación muestra las relaciones lineales entre las variables numéricas del dataset. Se observan algunas correlaciones positivas y negativas entre las variables, lo que indica posibles relaciones entre ellas. Por ejemplo el cociente entre el semieje orbital mayor y el periodo orbital (`pl_ratdor`) tiene una correlación positiva con el periodo orbital (`pl_orbper`) y una correlación negativa con la temperatura de equilibrio(`pl_eqt`). Respecto de la variable que se seleccionó como clase en el apartado anterior, el radio del exoplaneta (`pl_radj`) tiene una correlación positiva con la profundidad del tránsito (`pl_trandep`) y una correlación negativa con la gravedad superficial de la estrella (`st_logg`).

Para entender mejor la relación entre las variables con algo de correlación (umbral de 50% en valor absoluto) y seleccionar las mejores variables predictoras, se realiza un pair plot de las variables con mayor correlación positiva o negativa con la variable faltante. Se descartan como variables predictores aquellos que tengan más de 50% de valores faltantes.

``` {r most_correlated_variables, include=FALSE}

# Seleccionar de la matriz de correlación las variables con correlacion mayor o
# igual a 0.3 en valor absoluto con la variable faltante
correlated_vars <- names(which(abs(correlation_matrix_pearson["pl_radj", ]) >= 0.5))

# Se genera un dataframe con la correlacion entre las variables seleccionadas
# en correlated_vars y la variable faltante tomando de la matriz de correlacion
# solo las filas y columnas correspondientes a las variables seleccionadas
correlation_df <- data.frame(
  Variable = names(correlation_matrix_pearson[correlated_vars, "pl_radj"]),
  Correlacion = correlation_matrix_pearson[correlated_vars, "pl_radj"]
)

# Agregar una columna con la cantidad de valores faltantes
correlation_df$Faltantes <- sapply(correlation_df$Variable, function(x) sum(is.na(kepler_data[[x]])))

# Eliminar los registros que tenga màs de 50% de valores faltantes
correlation_df <- correlation_df[correlation_df$Faltantes <= 0.5 * nrow(kepler_data), ]

# Escribo a correlated_vars las variables seleccionadas
correlated_vars <- correlation_df$Variable

# Ordenar el dataframe por valor absoluto de correlación
# De mayor a menor
correlation_df <- correlation_df[order(abs(correlation_df$Correlacion), decreasing = TRUE), ]

# Eliminar la columna de indice
rownames(correlation_df) <- NULL

# Mostrar tabla formateada
kable(correlation_df, columns = c("Variable","Correlación","Faltantes"), align = "l")

```

```{r pair_plot_correlated_variables, include=FALSE, warning=FALSE}

pairs(kepler_data_num[correlated_vars], pch=10, cex=0.5)

```

Más allá de la correlación de la obvia relacion lineal entre el radio del exoplaneta en unidades jovianas y terrestres, parece haber una relación lineal entre el radio del exoplaneta y, en orden de correlación descendente, las siguientes variables:

- el cociente del radio planetario sobre el radio estelar (`pl_ratdor`)
- La masa de la estrella (`st_mass`) en términos de masas solares
- la temperatura de qeuilibrio del planeta (`pl_eqt`)

Se seleccionan como variables predictoras del radio del exploneta las variables con mayor correlación positiva o negativa que muestran una relación lineal con la variable faltante. 

# Detección de Valores Atípicos (Outliers)
Para las variables predictoras seleccionadas (`pl_ratdor`,`st_mass`,`pl_eqt`), se detectan valores atípicos en el dataset que puedan afectar el análisis y la predicción de la variable faltante (`pl_radj`).

```{r outliers_detection, include=FALSE}

# Seleccionar las variables predictoras
predictor_vars <- c("pl_ratdor", "st_mass", "pl_eqt")

# Crear un data frame con las variables predictoras
predictor_data <- kepler_data_num[predictor_vars]

# Normalizar los datos
predictor_data <- scale(predictor_data)

# Graficar los valores atípicos con un boxplot
boxplot(predictor_data, outline = TRUE, col = "skyblue", main = "Detección de Valores Atípicos")
```
Como puede observarse en el boxplot, las variables predictoras seleccionadas presentan valores atípicos que pueden afectar el análisis y la predicción de la variable faltante. Para tratar con esta situacié se puede considerar la utilización de métodos de regresión robustos que sean menos sensibles a los valores atípicos, como Huber. 

# Analisis de Regresión

Para analizar la relación entre las variables conocidas caracteristicas de los exoplanetas, se realiza un análisis de regresión lineal. La variable de dependiende `pl_radj` se intentará predecir a partir de las variables independientes:

- `pl_ratdor`
- `st_mass`
- `pl_eqt`

## Regresión Lineal Univariada

Las variablies de características de los sistemas exoplanetarios tales como periodo orbital, radio planetario, temperatura de la estrella central del sistema y masa del planeta pueden inferirse indirectamente a partir de otras variables como excentricidad orbital, distancia a la estrella, caracteristicas de la estrella y otras. Se explorar un análisis de regresión lineal univariada con varias variables independientes evaluando la capacidad de predicción de cada modelo planteado.

Se realiza un análisis de regresión lineal univariada para predecir el radio del exoplaneta (`pl_radj`) consecutivamente a partir de las variables independientes seleccionadas.

```{r univar_reg_pl_ratdor}

# Regresion de pl_radj con pl_ratdor
model_pl_ratdor <- lm(pl_radj ~ pl_ratdor, data = kepler_data_num)

# Resumen del modelo
model_pl_ratdor_summary <- summary(model_pl_ratdor)

model_pl_ratdor_summary
```

```{r univar_reg_pl_ratdor_plot, warning=FALSE}

# Scatter plot de pl_radj vs pl_ratdor con la recta de regresión en rojo
# y los margenes de confianza en gris
ggplot(kepler_data_num, aes(x = pl_ratdor, y = pl_radj)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "lm", color = "red", fill = "grey", alpha = 0.2) +
  labs(title = "Regresión Lineal: Radio del Exoplaneta segun Ratio sobre el Radio Estelar",
       x = "Ratio sobre Radio Estelar",
       y = "Radio del Exoplaneta (Júpiter)") +
  theme_minimal()

```

```{r univar_reg_pl_ratdor_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_pl_ratdor <- residuals(model_pl_ratdor)

# Estimar los valores ajustados
fit_val_pl_ratdor <- fitted(model_pl_ratdor)

# Crear un data frame con los residuos y valores ajustados
res_pl_ratdor_df <- data.frame(Fitted_Values = fit_val_pl_ratdor, Residuals = res_pl_ratdor)

# Scatter plot de residuos vs valores ajustados
ggplot(res_pl_ratdor_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r univar_reg_pl_ratdor_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_pl_ratdor, main = "Gráfico Q-Q de los Residuos")

```

```{r univar_reg_pl_ratdor_shapiro_test}

# Prueba de normalidad de Shapiro-Wilk
shapiro_test_pl_ratdor <- shapiro.test(res_pl_ratdor)

shapiro_test_pl_ratdor

```

```{r univar_reg_pl_ratdor_bp_test}

# Prueba de homocedasticidad de Breusch-Pagan
library(lmtest)

# Prueba de Breusch-Pagan
bp_test_pl_ratdor <- bptest(model_pl_ratdor)

bp_test_pl_ratdor

```

[Analisis sobre los resultados obtenidos]

Dado que el modelo de regresión lineal simple no es robusto a los valores atípicos, se analizar si una transformación logarítmica de las variables predictoras puede mejorar la capacidad predictiva del modelo mediante una prueba de Box-Cox.

```{r univar_reg_pl_ratdor_boxcox, warning=FALSE}

# Prueba de Box-Cox para transformar la variable st_rad
library(MASS)

# Prueba de Box-Cox
boxcox_pl_ratdor <- boxcox(model_pl_ratdor, lambda = seq(-2, 2, by = 0.1))

```
``` {r univar_reg_pl_ratdor_boxcox_optimal_lambda, warning=FALSE}

# Obtener el lambda óptimo
lambda_optimal <- boxcox_pl_ratdor$x[which.max(boxcox_pl_ratdor$y)]

lambda_optimal

```

El lambda óptimo es mayor que 0 (0.1414141), una transformación logarítmica de la variable `pl_ratdor` puede mejorar la capacidad predictiva del modelo de regresión lineal simple. Se realiza una regresión lineal con la variable transformada y se evalúa la capacidad predictiva del modelo.


``` {r univar_reg_pl_ratdor_log, warning=FALSE}

# Regresión de pl_radj con log(pl_ratdor) 
model_pl_ratdor_log <- lm(pl_radj ~ log(pl_ratdor), data = kepler_data_num)

model_pl_ratdor_log_summary <- summary(model_pl_ratdor_log)

model_pl_ratdor_log_summary

```

```{r univar_reg_pl_ratdor_log_plot, warning=FALSE}

# Scatter plot de pl_radj vs log(pl_ratdor) con la recta de regresión en rojo
# y los margenes de confianza en gris
ggplot(kepler_data_num, aes(x = log(pl_ratdor), y = pl_radj)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "lm", color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Regresión Lineal: Radio del Exoplaneta segun Logaritmo del Ratio sobre el Radio Estelar",
       x = "Logaritmo del Ratio sobre Radio Estelar",
       y = "Radio del Exoplaneta (Júpiter)") +
  theme_minimal()

```
```{r univar_reg_pl_ratdor_log_res_plot, warning=FALSE}    

# Obtener los residuos y valores ajustados
res_pl_ratdor_log <- residuals(model_pl_ratdor_log)

# Calcular los valores ajustados
fit_val_pl_ratdor_log <- fitted(model_pl_ratdor_log)

# Crear un data frame con los residuos y valores ajustados
res_pl_ratdor_log_df <- data.frame(
  Residuals = res_pl_ratdor_log,
  Fitted_Values = fit_val_pl_ratdor_log
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_pl_ratdor_log_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r univar_reg_pl_ratdor_log_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_pl_ratdor_log, main = "Gráfico Q-Q de los Residuos")

```

```{r univar_reg_st_mass}

# Regresion del radio del exploplaneta (pl_radj) 
# la masa estelar (st_mass) como predictor
model_st_mass <- lm(pl_radj ~ st_mass, data = kepler_data_num)

model_st_mass_summary <- summary(model_st_mass)

model_st_mass_summary
```

```{r univar_reg_st_mass_plot, warning=FALSE}

# Scatter plot de pl_radj vs st_mass con la recta de regresión en rojo
# y los margenes de confianza en gris
ggplot(kepler_data_num, aes(x = st_mass, y = pl_radj)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "lm", color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Regresión Lineal: Radio del Exoplaneta segun Masa Estelar",
       x = "Mas Estelar (Masas Solares)",
       y = "Radio del Exoplaneta (Júpiter)") +
  theme_minimal()

```

```{r univar_reg_st_mass_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_st_mass <- residuals(model_st_mass)

# Calcular los valores ajustados
fit_val_st_mass <- fitted(model_st_mass)

# Crear un data frame con los residuos y valores ajustados
res_st_mass_df <- data.frame(
  Residuals = res_st_mass,
  Fitted_Values = fit_val_st_mass
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_st_mass_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r univar_reg_pl_ratdor_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_st_mass, main = "Gráfico Q-Q de los Residuos")

```

```{r univar_reg_st_mass_shapiro_test}

# Prueba de normalidad de Shapiro-Wilk
shapiro_test_st_mass <- shapiro.test(res_st_mass)

shapiro_test_st_mass

```

```{r univar_reg_st_mass_bp_test}

# Prueba de homocedasticidad de Breusch-Pagan
library(lmtest)

# Prueba de Breusch-Pagan
bp_test_st_mass <- bptest(model_st_mass)

bp_test_st_mass

```

[Analisis sobre los resultados obtenidos]

```{r univar_reg_pl_eqt}

# Regresion del radio del exoplaneta (pl_radj) 
# utilizando la temperatura de equilibrio (pl_eqt)
# como predictor

model_pl_eqt <- lm(pl_radj ~ pl_eqt, data = kepler_data_num)

model_pl_eqt_summary <- summary(model_pl_eqt)

model_pl_eqt_summary

```

```{r univar_reg_pl_eqt_plot, warning=FALSE}

# Scatter plot de pl_radj vs pl_eqt con la recta de regresión en rojo
# y los margenes de confianza en gris
ggplot(kepler_data_num, aes(x = pl_eqt, y = pl_radj)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "lm", color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Regresión Lineal: Radio del Exoplaneta vs Temperatura de Equilibrio",
       x = "Tempertura de Equilibrio (K)",
       y = "Radio del Exoplaneta (Júpiter)") +
  theme_minimal()

```

```{r univar_reg_pl_eqt_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_pl_eqt <- residuals(model_pl_eqt)

# Calcular los valores ajustados
fit_val_pl_eqt <- fitted(model_pl_eqt)

# Crear un data frame con los residuos y valores ajustados
res_pl_eqt_df <- data.frame(
  Residuals = res_pl_eqt,
  Fitted_Values = fit_val_pl_eqt
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_pl_eqt_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r univar_reg_pl_eqt_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_pl_eqt, main = "Gráfico Q-Q de los Residuos")

```

```{r univar_reg_pl_eqt_shapiro_test}

# Prueba de normalidad de Shapiro-Wilk
shapiro_test_pl_eqt <- shapiro.test(res_pl_eqt)

shapiro_test_pl_eqt

```

```{r univar_reg_pl_rvamp_rvamp_bp_test}

# Prueba de homocedasticidad de Breusch-Pagan
library(lmtest)

# Prueba de Breusch-Pagan
bp_test_pl_eqt <- bptest(model_pl_eqt)

bp_test_pl_eqt

```

[Analisis sobre los resultados obtenidos]

## Regresión Lineal Multivariada

Se realiza un análisis de regresión lineal multivariada para predecir el radio del exoplaneta (`pl_radj`) simultaneamente a partir del cociente del radio planetario sobre el radio estelar (`pl_ratdor`), La masa de la estrella (`st_mass`) en términos de masas solares y la temperatura de qeuilibrio del planeta (`pl_eqt`)).

```{r multivar_reg}

# Regresion de pl_radj con pl_ratdor, st_mass y pl_eqt
model_multivar <- lm(pl_radj ~ pl_ratdor + st_mass + pl_eqt, data = kepler_data_num)

# Resumen del modelo
model_multivar_summary <- summary(model_multivar)

model_multivar_summary

```

```{r multivar_reg_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_multivar <- residuals(model_multivar)

# Calcular los valores ajustados
fit_val_multivar <- fitted(model_multivar)

# Crear un data frame con los residuos y valores ajustados
res_multivar_df <- data.frame(
  Residuals = res_multivar,
  Fitted_Values = fit_val_multivar
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_multivar_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

```{r multivar_reg_qq_plot, warning=FALSE}

# Crear un gráfico Q-Q de los residuos
qqnorm(res_multivar, main = "Gráfico Q-Q de los Residuos")

```

```{r multivar_reg_shapiro_test}

# Prueba de normalidad de Shapiro-Wilk
shapiro_test_multivar <- shapiro.test(res_multivar)

shapiro_test_multivar

```

```{r multivar_reg_bp_test}

# Prueba de homocedasticidad de Breusch-Pagan
library(lmtest)

# Prueba de Breusch-Pagan
bp_test_multivar <- bptest(model_multivar)

bp_test_multivar

```

``` {r multivar_reg_boxcox, warning=FALSE}

# Prueba de Box-Cox para transformar la variable pl_radj
library(MASS)

# Prueba de Box-Cox
boxcox_multivar <- boxcox(model_multivar, lambda = seq(-2, 2, by = 0.1))

```
``` {r multivar_reg_boxcox_optimal_lambda, warning=FALSE}

# Obtener el lambda óptimo
lambda_optimal <- boxcox_multivar$x[which.max(boxcox_multivar$y)]

lambda_optimal

```

El lambda óptimo es mayor que 0 (0.7070707) por lo que una transformación de raíz cuadrada de la variable `pl_radj` puede mejorar la capacidad predictiva del modelo de regresión lineal múltiple. Se realiza una regresión lineal con la variable transformada y se evalúa la capacidad predictiva del modelo.

```{r multivar_reg_sqrt, warning=FALSE}

# Regresión de pl_radj con sqrt(pl_ratdor + st_mass + pl_eqt)
model_multivar_sqrt <- lm(pl_radj ~ sqrt(pl_ratdor + st_mass + pl_eqt), data = kepler_data_num)

model_multivar_sqrt_summary <- summary(model_multivar_sqrt)

model_multivar_sqrt_summary
```

```{r multivar_reg_sqrt_res_plot, warning=FALSE}

# Obtener los residuos y valores ajustados
res_multivar_sqrt <- residuals(model_multivar_sqrt)

# Calcular los valores ajustados
fit_val_multivar_sqrt <- fitted(model_multivar_sqrt)

# Crear un data frame con los residuos y valores ajustados
res_multivar_sqrt_df <- data.frame(
  Residuals = res_multivar_sqrt,
  Fitted_Values = fit_val_multivar_sqrt
)

# Scatter plot de residuos vs valores ajustados
ggplot(res_multivar_sqrt_df, aes(x = Fitted_Values, y = Residuals)) +
  geom_point(color = "steelblue") +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Residuos vs Valores Ajustados",
       x = "Valores Ajustados",
       y = "Residuos") +
  theme_minimal()

```

## Regresión Logística

Para predecir la habitabilidad de los exoplanetas, se realiza un análisis de regresión logística utilizando las variables conocidas de los exoplanetas y las estrellas del sistema. Se seleccionan las variables conocidas de los exoplanetas y las estrellas como variables independientes y la habitabilidad como variable dependiente.

Existen varios indicadores de habitabilidad de los exoplanetas, como la temperatura de equilibrio (`pl_eqt`), la insolación (`pl_insol`), la distancia orbital semieje mayor (`pl_orbsmax`), la temperatura efectiva de la estrella (`st_teff`), la masa de la estrella (`st_mass`), la luminosidad de la estrella (`st_lum`), la gravedad superficial de la estrella (`st_logg`) y la edad de la estrella (`st_age`). Se seleccionan estas variables como posibles predictores de la habitabilidad de los exoplanetas.

La determinación de la habitabilidad de un exoplaneta es un tema complejo y multifactorial que depende de varios indicadores físicos y químicos. Si bien no existe una fórmula única universalmente aceptada para calcular la "habitabilidad", se pueden combinar los indicadores antes mencionados para aproximar el potencial de habitabilidad de un exoplaneta. Una de las aproximaciones más comunes es usar una combinación ponderada de las condiciones adecuadas para la presencia de agua líquida, ya que esta es fundamental para la vida tal como la conocemos.

Así con los indicadores seleccionados definimos un Índice de Habitabilidad Planetaria (PHI - Planetary Habitability Index) como una función normalizada que combine los indicadores clave:

$$
\text{PHI} = w_1 \cdot f_1(\text{pl_eqt}) + w_2 \cdot f_2(\text{pl_insol}) + w_3 \cdot f_3(\text{pl_orbsmax}) + w_4 \cdot f_{\text{estelar}} 
$$ Donde:

-   $w_i$ son los pesos normalizados asociados a cada indicador sumando 1.
-   $f_i(x)$ son funciones de transformación o normalización que convierten las medidas en valores entre 0 y 1, según el rango de habitabilidad conocido.
-   $f_{\text{estelar}}$ es una función que combina las propiedades estelares de la estrella anfitriona y a su vez es la ponderación de los siguientes parámetros estelares:

$$
    f_{\text{estelar}} = w_5 \cdot f_5(\text{st_teff}) + w_6 \cdot f_6(\text{st_mass}) + w_7 \cdot f_7(\text{st_lum}) + w_8 \cdot f_8(\text{st_logg}) + w_9 \cdot f_9(\text{st_age})
    $$

Estas variables se consideran como posibles predictores de la habitabilidad de los exoplanetas cuando están en determinados rangos.

**Temperatura de equilibrio** (`pl_eqt`): Idealmente, debe estar en un rango compatible con agua líquida, aproximadamente entre 0°C y 100°C. Así la normalización resultan en:

$$
f_i(\text{pl_eqt}) = \max\left(0, \min\left(1, \frac{\text{pl_eqt} - T_{\text{min}}}{T_{\text{max}} - T_{\text{min}}}\right)\right)
$$ Donde $T_{\text{min}}$ y $T_{\text{max}}$ son los límites inferiores y superiores. El agua líquida, esencial para la vida, puede existir en un rango de temperaturas superficiales de aproximadamente 273K (0 °C) a 373K (100 °C). Sin embargo, debido a factores atmosféricos y de presión, este rango puede extenderse ligeramente: $T_{\text{min}}=200K$ puede ser el umbral inferior, considerando atmósferas densas como la de Marte y $T_{\text{max}}=400K$ puede considerarse el umbral superior, considerando atmósferas con alta presión como la de Venus.

Según la literatura especializada el peso de la temperatura de equilibrio en el índice de habitabilidad es de $w_1=0.45$ cuando se considera la temperatura de equilibrio como un indicador preponderante de habitabilidad y no se tienen muchos más datos del planeta.

**Insolación** (`pl_insol`): La insolación es la cantidad de energía recibida por el planeta y es un indicador importante de la habitabilidad. La insolación se mide en unidades de flujo de energía recibida por unidad de área y se puede normalizar en un rango de 0 a 1. La insolación ideal para la vida es aquella que permite la presencia de agua líquida en la superficie del planeta (generalmente valores cercanos a la Tierra son ideales). La insolación se puede normalizar considerando que La Tierra tiene una insolación de 1S (donde $S$ es la insolación solar a la distancia de la Tierra) y se puede considerar que la vida puede existir en un rango de insolación de $I_{min}=0.3S$ (aproximadamente el límite interior de la zona habitable para una estrella como el Sol, más allá de este valor el agua podría congelarse) a $I_{max}=1,7S$ (aproximadamente el límite exterior de la zona habitable, más allá de este valor el agua podría evaporarse). Así la normalización resulta en:

$$
f_2(\text{pl_insol}) = \max\left(0, \min\left(1, \frac{\text{pl_insol} - I_{\text{min}}}{I_{\text{max}} - I_{\text{min}}}\right)\right)
$$

La insolación es un factor crítico para mantener agua líquida en la superficie del planeta, pero su impacto depende de otros factores como la atmósfera y el albedo, según la literatura especializada el peso de la insolación en el índice de habitabilidad es de $w_2=0.30$. Es importante destacar que El rango de $I_{min}$ e $I_{max}$ puede variar según la luminosidad de la estrella, ya que la zona habitable cambia en función del tipo estelar por lo que esta estimación sirve para estrellas similares al Sol.

**Distancia orbital semieje mayor** (`pl_orbsmax`): La distancia orbital semieje mayor es un indicador de la zona habitable de un sistema planetario. La distancia orbital semieje mayor se mide en unidades astronómicas (UA) y se puede normalizar en un rango de 0 a 1. La distancia orbital semieje mayor ideal para la vida es aquella que permite la presencia de agua líquida en la superficie del planeta. La distancia orbital semieje mayor se puede normalizar considerando que La Tierra tiene una distancia orbital semieje mayor de 1 UA y se puede considerar que la vida puede existir en un rango de distancias de $D_{\text{min}}=1,05$ UA (aproximadamente el límite interior de la zona habitable para una estrella como el Sol, más allá de este valor el agua podría congelarse) a $D_{\text{max}}=2$ UA (aproximadamente el límite exterior de la zona habitable, más allá de este valor el agua podría evaporarse). Así la normalización resulta en:

$$
f_3(\text{pl_orbsmax}) = \max\left(0, \min\left(1, \frac{\text{pl_orbsmax} - D_{\text{min}}}{D_{\text{max}} - D_{\text{min}}}\right)\right)
$$ En la mayoría de los modelos, el peso para el valor normalizado de `pl_orbsmax` oscila entre 15% y 25%. Esto se debe a que `pl_orbsmax` complementa indicadores más directos como `pl_eqt` (temperatura de equilibrio) y `pl_insol` (insolación). Se tomará un peso de $w_3=0.20$.

**Propiedades estelares** (`st_teff`, `st_mass`, `st_lum`, `st_logg`, `st_age`): Las propiedades estelares son cruciales para determinar la habitabilidad de un exoplaneta. La estabilidad y tipo de estrella son cruciales puesto que estrellas demasiado masivas tienen vidas cortas y no permiten la evolución de la vida compleja mientras que estrellas con alta actividad estelar pueden emitir radiación peligrosa. La normalización de las propiedades estelares se realiza de manera similar a los indicadores planetarios, considerando los rangos de habitabilidad conocidos para estrellas similares al Sol. La normalización de las propiedades estelares (`st_teff`, `st_mass`, `st_lum`, `st_logg`, `st_age`) es crucial para combinarlas en un único valor que refleje su influencia en la habitabilidad. Cada propiedad se normaliza al rango [0, 1], con valores cercanos a 1 representando condiciones ideales para la habitabilidad.

$$
f_{\text{estelar}} = w_5 \cdot f_5(\text{st_teff}) + w_6 \cdot f_6(\text{st_mass}) + w_7 \cdot f_7(\text{st_lum}) + w_8 \cdot f_8(\text{st_logg}) + w_9 \cdot f_9(\text{st_age})
$$

Donde: - f5(x) es la normalización de la temperatura efectiva de la estrella (`st_teff`) con la normalización de la temperatura efectiva de la estrella ideal para la habitabilidad en el rango de 4000K a 6000K. - f6(x) es la normalización de la masa de la estrella (`st_mass`) con la normalización de la masa de la estrella ideal para la habitabilidad en el rango de 0.8 a 1.2 masas solares. - f7(x) es la normalización de la luminosidad de la estrella (`st_lum`) con la normalización de la luminosidad de la estrella ideal para la habitabilidad en el rango de -0.5 (estrella demasiado débil) a 0.5 (estrella con radiación excesiva) veces la luminosidad solar. - f8(x) es la normalización de la gravedad superficial de la estrella (`st_logg`) con la normalización de la gravedad superficial de la estrella ideal para la habitabilidad en el rango de 4.0 (estrella en evolución fuera de la secuencia principal) a 4.5 (condiciones poco comunes para estrellas típicas). - f9(x) es la normalización de la edad de la estrella (`st_age`) con la normalización de la edad de la estrella ideal para la habitabilidad en el rango de 1 a 10 gigaaños.

En la literatura especializada se considera que el peso de las propiedades estelares en el índice de habitabilidad es de $w_4=0.1$.

```{r log_reg}

library(dplyr)

# Crear un data frame con las variables seleccionadas
kepler_data_logistic <- kepler_data_num %>%
  dplyr::select(pl_eqt, pl_insol, pl_orbsmax, st_teff, st_mass, st_lum, st_logg, st_age)

# Normalizar las variables
kepler_data_logistic_normalized <- kepler_data_logistic %>%
  mutate(
    pl_eqt_normalized = pmin(1, pmax(0, (pl_eqt - 200) / (400 - 200))),
    pl_insol_normalized = pmin(1, pmax(0, (pl_insol - 0.3) / (1.7 - 0.3))),
    pl_orbsmax_normalized = pmin(1, pmax(0, (pl_orbsmax - 1.05) / (2 - 1.05))),
    st_teff_normalized = pmin(1, pmax(0, (st_teff - 4000) / (6000 - 4000))),
    st_mass_normalized = pmin(1, pmax(0, (st_mass - 0.8) / (1.2 - 0.8))),
    st_lum_normalized = pmin(1, pmax(0, (st_lum + 0.5) / 1)),
    st_logg_normalized = pmin(1, pmax(0, (st_logg - 4) / (4.5 - 4))),
    st_age_normalized = pmin(1, pmax(0, (st_age - 1) / (10 - 1)))
  )

# Calcular el índice de habitabilidad planetaria (PHI)
kepler_data_logistic_normalized <- kepler_data_logistic_normalized %>%
  mutate(
    phi = 0.45 * pl_eqt_normalized + 0.30 * pl_insol_normalized + 0.20 * pl_orbsmax_normalized +
      0.1 * (0.45 * st_teff_normalized + 0.30 * st_mass_normalized + 0.20 * st_lum_normalized + 0.15 * st_logg_normalized + 0.10 * st_age_normalized)
  )

# Crear un modelo de regresión logística
model_logistic <- glm(phi ~ ., data = kepler_data_logistic_normalized, family = binomial)

model_logistic_summary <- summary(model_logistic)

model_logistic_summary

```
```{r log_reg_plot, warning=FALSE}

# Graficar la curva logistica del modelo
# Crear un data frame con los valores de PHI y las probabilidades predichas
# de habitabilidad. Seleccionar solo los registros donde se conoce la habitabilidad
phi_prob <- predict(model_logistic, type = "response")

# Filtrar los registros donde se conoce la habitabilidad
kepler_data_logistic_normalized <- kepler_data_logistic_normalized %>%
  filter(!is.na(phi))

phi_prob_df <- data.frame(PHI = kepler_data_logistic_normalized$phi, Probabilidad = phi_prob)

# Scatter plot de PHI vs Probabilidad
ggplot(phi_prob_df, aes(x = PHI, y = Probabilidad)) +
  geom_point(color = "steelblue") +
  geom_smooth(method = "glm", method.args = list(family = "binomial"), color = "indianred", fill = "grey", alpha = 0.2) +
  labs(title = "Curva Logística del Modelo de Regresión",
       x = "PHI",
       y = "Probabilidad") +
  theme_minimal()

```
